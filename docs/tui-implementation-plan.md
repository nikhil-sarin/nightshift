# NightShift TUI Implementation Plan

**Generated by:** GPT-5.1
**Framework:** prompt_toolkit (chosen for native Vi keybindings, async support, battle-tested in IPython)
**Goal:** Replicate Slack integration features as an interactive terminal UI with vim-like keybindings (ranger-style)

---

1. Architecture overview
------------------------

### 1.1 High-level structure

Add a new TUI package alongside the existing CLI:

```text
nightshift/
  interfaces/
    cli.py
    tui/
      __init__.py
      app.py          # Application factory + event loop glue
      layout.py       # prompt_toolkit Layout / containers / floats
      keybindings.py  # Vi-style keymaps + command-line mode
      models.py       # UI state + view models
      controllers.py  # Actions that call TaskPlanner/TaskQueue/AgentManager
      widgets.py      # Task list, detail panel, status bar, modals
      run.py          # `nightshift tui` entrypoint (called from cli)
```

Core idea: reuse **exactly the same core components** that CLI and Slack use:

- `Config` â†’ paths to DB, logs, output, notifications.
- `TaskQueue` â†’ list/query/update tasks.
- `TaskPlanner` â†’ async planning for `submit`.
- `AgentManager` â†’ execute/pause/resume/kill tasks.
- `Notifier` / notifications JSON â†’ feed rich summary tab.
- `OutputViewer` logic â†’ inspiration for execution/details rendering (but keep TUI read-only).

The TUI is just another interface layer; **no new business logic**. All task lifecycle changes go via `TaskQueue` and `AgentManager` just like CLI & Slack.

### 1.2 Integration with core components

Initialize once in `app.py`:

```python
# nightshift/interfaces/tui/app.py (conceptual)
from nightshift.core.config import Config
from nightshift.core.logger import NightShiftLogger
from nightshift.core.task_queue import TaskQueue
from nightshift.core.task_planner import TaskPlanner
from nightshift.core.agent_manager import AgentManager
from .models import UIState
from .controllers import TUIController

def build_backends():
    cfg = Config()
    logger = NightShiftLogger(log_dir=str(cfg.get_log_dir()))
    queue = TaskQueue(db_path=str(cfg.get_database_path()))
    planner = TaskPlanner(logger, tools_reference_path=str(cfg.get_tools_reference_path()))
    agent = AgentManager(queue, logger, output_dir=str(cfg.get_output_dir()))
    return cfg, logger, queue, planner, agent
```

`TUIController` wraps these backend objects and exposes **UI-safe**, high-level methods:

```python
controller.submit_task(...)
controller.approve_task(...)
controller.pause_task(...)
controller.refresh_tasks()
controller.load_task_details(task_id)
```

The controller updates a shared `UIState` instance used by widgets.

Slack/TUI parity is straightforward because Slack handlers already show you the mappings:
- `handle_submit` â†’ `TaskPlanner.plan_task` + `TaskQueue.create_task`.
- `handle_approval` â†’ `TaskQueue.update_status(COMMITTED)` + `AgentManager.execute_task`.
- `handle_queue/status/cancel/pause/resume/kill` â†’ all mapped to core methods.

You can largely **mirror SlackEventHandler methods** into `TUIController`, minus JSON/HTTP handling.

### 1.3 Event loop & async strategy

Use `prompt_toolkit`'s asyncio integration:

- Create `Application` with `full_screen=True`.
- Run via `asyncio.run(app.run_async())` from `run.py` or CLI.

Key patterns:

- **Background work** (planning, execution calls) is blocking Python that shells out to `claude`. Run those via threads to keep the TUI responsive:

```python
import threading
from prompt_toolkit.application.current import get_app

def run_in_thread(func, *args, **kwargs):
    def worker():
        try:
            func(*args, **kwargs)
        finally:
            # Ask PT to re-render when done / on progress updates
            get_app().invalidate()
    threading.Thread(target=worker, daemon=True).start()
```

- **Periodic refresh** via asyncio task:

```python
async def auto_refresh(controller, app):
    while True:
        await asyncio.sleep(2)
        controller.refresh_tasks()
        app.invalidate()
```

Hook it in `app.pre_run_callables`:

```python
app.pre_run_callables.append(lambda: app.create_background_task(auto_refresh(controller, app)))
```

Concurrency rules:

- Thread workers:
  - Call into `TaskPlanner`, `TaskQueue`, `AgentManager`.
  - Update the shared `UIState` (simple Python dataclass; no heavy locking needed if updates are coarse-grained).
  - Then call `get_app().invalidate()`; **do not** call other prompt_toolkit APIs from threads.
- Async tasks:
  - Only manipulate `UIState` and `Application` on the asyncio loop thread.

2. UI layout design
-------------------

### 2.1 Overall layout

Ranger-style 3-part layout:

```text
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Task List                â”‚ Task Detail / Tabs                â”‚
â”‚ (queue browser)          â”‚ - Overview                        â”‚
â”‚                          â”‚ - Exec log / progress             â”‚
â”‚                          â”‚ - Files changed                   â”‚
â”‚                          â”‚ - Summary (Slack-style)           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Status line (mode, filter, selected task, busy state)       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
: (appears as command line overlay when in command mode)
```

Use PT layout building blocks:

- `HSplit` for vertical stacking (main area + status).
- `VSplit` for left/right.
- `FloatContainer` to host modal dialogs and a command-line overlay.

### 2.2 Panels

**Left panel: TaskList**

- Shows tasks from `TaskQueue.list_tasks()`, optionally filtered by status.
- Each line:

  - Status emoji (same mapping Slack uses: ğŸ“ staged, â³ running, âœ… completed, âŒ failed, ğŸš« cancelled).
  - Task ID.
  - Truncated description.
  - Age or created date.

- Selected row highlighted with reverse/bold.
- Scrollable (internal first-visible index tracked in `UIState`).

**Right panel: Detail tabs**

Tabs stored as `state.detail_tab`:

1. `overview`

   - Task ID, status (color-coded), created/started/completed times.
   - Description (multi-line).
   - Estimated tokens/time.
   - Allowed tools list.
   - Allowed directories & `needs_git`.
   - Error message if any.

2. `exec` (Execution / live output)

   - For tasks with `result_path`:
     - Show last N lines of parsed stdout, using a light adaptation of `OutputViewer`'s parsing logic (but just text, minimal decoration).
   - For RUNNING:
     - Auto-refresh from output JSON each few seconds to show incremental log.
     - Show `execution_time` field if present.
   - For COMPLETED/FAILED:
     - Static snippet; user can re-open to see historical logs.

3. `files` (File changes)

   - If `~/.nightshift/output/task_XXX_files.json` exists:
     - Lists created / modified / deleted counts & first few filenames, same limit rules as SlackFormatter.
   - Use small headers and bullet lines.

4. `summary` (Slack-style completion summary)

   - Load `~/.nightshift/notifications/task_XXX_notification.json` (if exists).
   - Render text equivalent to `SlackFormatter.format_completion_notification`:
     - What you asked for.
     - What NightShift found/created (if we can re-extract from output).
     - Execution metrics.
     - What NightShift did (files).
     - Result path.

Tabs changed with keys: `H`/`L` or `1`â€“`4`.

**Modals / Popups**

Use `Float` over a `FloatContainer`:

- Submit dialog:
  - `TextArea` for description.
  - Checkbox or toggle for auto-approve.
  - Optional simple input for `allow-dir` (comma-separated or separate dialog; v1 can skip directories).
- Details modal (Slack "Details" equivalent):
  - Full description.
  - Tools.
  - Allowed directories (all).
  - System prompt snippet (scrollable).
- Confirmation dialogs:
  - On `kill`, `cancel`, etc.

PT components: `prompt_toolkit.widgets.Dialog`, `Label`, `TextArea`, `Button`.

### 2.3 Navigation flow

- Focus is either on:
  - Left task list,
  - Right detail panel (read-only),
  - Command line overlay,
  - Modal dialog (when shown).

Flow:

- Start in task list (left).
- `j` / `k` to move selection up/down.
- `h` / `l` to move focus left/right.
- `H` / `L` or digits to change detail tab.
- `Enter` or `d` to open Details modal.
- `s` to open Submit modal.
- `:` to enter command mode (bottom command line).

PT filters: `has_focus(...)` + `vi_navigation_mode` / `vi_insert_mode` / custom `in_command_mode` boolean from `UIState`.

3. Keybinding scheme
--------------------

Use PT's `load_vi_bindings()` and merge with your own:

```python
from prompt_toolkit.key_binding.bindings.vi import load_vi_bindings
from prompt_toolkit.key_binding import KeyBindings, merge_key_bindings

base_vi = load_vi_bindings()
custom = KeyBindings()
kb = merge_key_bindings([base_vi, custom])
```

### 3.1 Modes

- Vi modes:
  - Normal / Insert handled by PT.
- Additional "command mode":
  - Triggered by `:` (in normal mode).
  - Shows a small one-line `Buffer` at bottom with `:` prefix.
  - On `<Enter>` parse/execute; on `<Esc>` exit.

Track `state.command_active: bool` to control overlays and keybinding filters.

### 3.2 Normal-mode bindings

Assume filter `~vi_insert_mode` (navigation mode):

**Movement & focus**

- `j` / `k` â†’ move selection down/up in task list if left panel focused.
- `g` / `G` â†’ first / last task.
- `Ctrl+F` / `Ctrl+B` or `PageDown/PageUp` â†’ page scroll (optional).
- `h` / `l` â†’ change panel focus (left â†” right).
- `H` / `L` â†’ previous / next detail tab.
- `1` / `2` / `3` / `4` â†’ direct tab selection (overview/exec/files/summary).

**Task actions** (operate on selected task):

- `Enter` or `d`:
  - Open Details modal (Slack "â„¹ï¸ Details").
- `a`:
  - Approve (`TaskStatus.STAGED` â†’ `COMMITTED` and schedule `AgentManager.execute_task` in a thread).
- `r`:
  - Reject/cancel:
    - If STAGED/COMMITTED: `TaskStatus.CANCELLED`.
- `p`:
  - Pause running: `AgentManager.pause_task`.
- `P`:
  - Resume paused: `AgentManager.resume_task`.
- `X`:
  - Kill running/paused: confirm dialog then `AgentManager.kill_task`.

**Submission & queue**

- `s`:
  - Open Submit modal (handles planner + optional auto-approve).
- `f`:
  - Quick filter status: open tiny list popup to pick status (all/staged/running/completed/etc.).
  - Or simple rotate: ALL â†’ STAGED â†’ RUNNING â†’ COMPLETED â†’ ALL.

**Global**

- `:`:
  - Enter command mode and focus command buffer.
- `q`:
  - Quit (optionally confirm if tasks running).
- `Ctrl+L`:
  - Hard refresh via `controller.refresh_tasks()` and re-read selected task details.

### 3.3 Command-line (\":\" mode) commands

Examples to mirror CLI/Slack:

- `submit ...` â€“ non-interactive submission:

  - `:submit Download and summarize arxiv 2501.12345`
  - Equivalent to CLI `nightshift submit \"<text>\"`.
  - Optional `!` for auto-approve: `:submit! \"do X\"`.

- `approve [task_id]` â€“ approve selected or given task.
- `cancel [task_id]`
- `pause [task_id]`
- `resume [task_id]`
- `kill [task_id]`
- `queue [status]` â€“ set filter and refresh.
- `status [task_id]` â€“ select that task & show overview.
- `results [task_id]` â€“ select and open Summary tab.
- `help` â€“ open help popup / cheat sheet.
- `quit` / `q` â€“ exit TUI.

Implementation:

- Command buffer is a PT `Buffer` with its own keybindings (`Enter`/`Esc`).
- On `<Enter>`, parse using simple split:

```python
cmdline = state.command_buffer.strip()
if cmdline.startswith(':'):
    cmdline = cmdline[1:]
parts = shlex.split(cmdline)
# dispatch parts[0], parts[1:]
```

4. Implementation plan
----------------------

### 4.1 File structure

Under `nightshift/interfaces/tui/`:

- `__init__.py` â€“ maybe export `run()` helper.
- `models.py` â€“ dataclasses for UI state and view-models.
- `controllers.py` â€“ thin layer that calls TaskPlanner, TaskQueue, AgentManager.
- `widgets.py` â€“ `UIControl` wrappers for list, detail, status, modals.
- `layout.py` â€“ build prompt_toolkit `Layout` + `FloatContainer`.
- `keybindings.py` â€“ define `create_keybindings(state, controller)` returning merged KeyBindings.
- `app.py` â€“ glue: create backends, state, controller, layout, kb, Application; set auto-refresh.
- `run.py` â€“ `async def run_tui()` used by CLI.

Add CLI integration:

```python
# in nightshift/interfaces/cli.py
@cli.command()
@click.pass_context
def tui(ctx):
    \"\"\"Launch interactive terminal UI\"\"\"
    from .tui.app import create_app
    import asyncio
    app = create_app()  # will build its own Config etc., or accept ctx.obj
    asyncio.run(app.run_async())
```

You can optionally pass the already-initialized backends from `cli` to TUI instead of re-initializing.

### 4.2 Models (`models.py`)

UI state:

```python
from dataclasses import dataclass, field
from typing import List, Optional, Dict
from datetime import datetime

@dataclass
class TaskRow:
    task_id: str
    status: str        # lowercase: 'staged', 'running', ...
    description: str
    created_at: Optional[str]
    # Derived fields (not persisted)
    status_emoji: str = ''
    status_color: str = ''

@dataclass
class SelectedTaskState:
    task_id: Optional[str] = None
    # Cached details to avoid re-query on every render
    details: Optional[dict] = None       # from TaskQueue.get_task().to_dict()
    exec_snippet: str = ''
    files_info: Optional[dict] = None    # parsed _files.json
    summary_info: Optional[dict] = None  # parsed _notification.json
    last_loaded: Optional[datetime] = None

@dataclass
class UIState:
    tasks: List[TaskRow] = field(default_factory=list)
    selected_index: int = 0
    scroll_offset: int = 0
    status_filter: Optional[str] = None   # 'staged', 'running', etc.
    focus_panel: str = \"list\"             # 'list'|'detail'
    detail_tab: str = \"overview\"          # 'overview'|'exec'|'files'|'summary'

    # Modes
    command_active: bool = False
    command_buffer: str = \"\"

    # Meta
    message: Optional[str] = None         # transient status bar text
    busy: bool = False                    # global busy
    busy_label: str = \"\"

    selected_task: SelectedTaskState = field(default_factory=SelectedTaskState)
```

Helper to map `Task` â†’ `TaskRow`:

```python
from nightshift.core.task_queue import Task, TaskStatus

def task_to_row(task: Task) -> TaskRow:
    status_upper = task.status.upper()
    emoji_map = {
        \"STAGED\": \"ğŸ“\",
        \"COMMITTED\": \"âœ”ï¸\",
        \"RUNNING\": \"â³\",
        \"PAUSED\": \"â¸ï¸\",
        \"COMPLETED\": \"âœ…\",
        \"FAILED\": \"âŒ\",
        \"CANCELLED\": \"ğŸš«\",
    }
    color_map = {
        \"staged\": \"yellow\",
        \"committed\": \"blue\",
        \"running\": \"cyan\",
        \"paused\": \"magenta\",
        \"completed\": \"green\",
        \"failed\": \"red\",
        \"cancelled\": \"ansired\",
    }
    return TaskRow(
        task_id=task.task_id,
        status=task.status,
        description=task.description,
        created_at=task.created_at,
        status_emoji=emoji_map.get(status_upper, \"â“\"),
        status_color=color_map.get(task.status, \"white\"),
    )
```

### 4.3 Controllers (`controllers.py`)

Encapsulate all operations that talk to NightShift core and mutate `UIState`.

Sketch:

```python
import threading
from datetime import datetime
from prompt_toolkit.application.current import get_app
from nightshift.core.task_queue import TaskQueue, TaskStatus
from nightshift.core.task_planner import TaskPlanner
from nightshift.core.agent_manager import AgentManager
from nightshift.core.logger import NightShiftLogger
from .models import UIState, task_to_row

class TUIController:
    def __init__(self, state: UIState,
                 queue: TaskQueue,
                 planner: TaskPlanner,
                 agent: AgentManager,
                 logger: NightShiftLogger,
                 config):
        self.state = state
        self.queue = queue
        self.planner = planner
        self.agent = agent
        self.logger = logger
        self.config = config

    # ----- utility -----

    def _invalidate(self):
        try:
            get_app().invalidate()
        except Exception:
            pass

    def _in_thread(self, func, *args, **kwargs):
        def worker():
            try:
                func(*args, **kwargs)
            finally:
                self.state.busy = False
                self.state.busy_label = \"\"
                self._invalidate()
        threading.Thread(target=worker, daemon=True).start()

    # ----- data refresh -----

    def refresh_tasks(self):
        if self.state.status_filter:
            from nightshift.core.task_queue import TaskStatus as TS
            tasks = self.queue.list_tasks(TS(self.state.status_filter))
        else:
            tasks = self.queue.list_tasks()
        self.state.tasks = [task_to_row(t) for t in tasks]
        if self.state.selected_index >= len(self.state.tasks):
            self.state.selected_index = max(0, len(self.state.tasks) - 1)
        self._ensure_selected_task_loaded()

    def _ensure_selected_task_loaded(self):
        if not self.state.tasks:
            self.state.selected_task = SelectedTaskState()
            return
        row = self.state.tasks[self.state.selected_index]
        st = self.state.selected_task
        if st.task_id != row.task_id:
            # reload
            t = self.queue.get_task(row.task_id)
            st.task_id = row.task_id
            st.details = t.to_dict() if t else None
            st.exec_snippet = self._load_exec_snippet(t)
            st.files_info = self._load_files_info(t)
            st.summary_info = self._load_summary_info(t)
            st.last_loaded = datetime.utcnow()

    # ... helper _load_exec_snippet/_load_files_info/_load_summary_info read JSON files
```

**Submit task**:

```python
    def submit_task(self, description: str, auto_approve: bool = False, allow_dirs=None):
        self.state.busy = True
        self.state.busy_label = \"Planning task...\"
        self._invalidate()

        def work():
            try:
                plan = self.planner.plan_task(description)
                import uuid
                task_id = f\"task_{uuid.uuid4().hex[:8]}\"
                allowed_dirs = list(plan.get('allowed_directories', []))
                if allow_dirs:
                    from pathlib import Path
                    for d in allow_dirs:
                        p = str(Path(d).resolve())
                        if p not in allowed_dirs:
                            allowed_dirs.append(p)
                task = self.queue.create_task(
                    task_id=task_id,
                    description=plan['enhanced_prompt'],
                    allowed_tools=plan['allowed_tools'],
                    allowed_directories=allowed_dirs,
                    needs_git=plan.get('needs_git', False),
                    system_prompt=plan['system_prompt'],
                    estimated_tokens=plan['estimated_tokens'],
                    estimated_time=plan['estimated_time'],
                )
                self.logger.log_task_created(task_id, description)
                if auto_approve:
                    self.queue.update_status(task_id, TaskStatus.COMMITTED)
                    self.logger.log_task_approved(task_id)
                    self.agent.execute_task(task)  # blocking inside thread
                # refresh list & select new
                self.refresh_tasks()
                # select task_id row
                for idx, row in enumerate(self.state.tasks):
                    if row.task_id == task_id:
                        self.state.selected_index = idx
                        break
                self.state.message = f\"Created task {task_id}\" + (\" and executing\" if auto_approve else \"\")
            except Exception as e:
                self.state.message = f\"Error submitting task: {e}\"

        self._in_thread(work)
```

**Approve/Reject/Pause/Resume/Kill** mirror Slack equivalents:

```python
    def approve_selected(self):
        row = self._current_row()
        if not row:
            return
        t = self.queue.get_task(row.task_id)
        if not t or t.status != TaskStatus.STAGED.value:
            self.state.message = \"Task not in STAGED state\"
            return
        self.queue.update_status(t.task_id, TaskStatus.COMMITTED)
        self.logger.log_task_approved(t.task_id)
        self.state.busy = True
        self.state.busy_label = f\"Executing {t.task_id}...\"
        self._invalidate()
        self._in_thread(lambda: self.agent.execute_task(t))
```

Pause/resume/kill simply delegate to `agent.pause_task` etc. and set `state.message` based on result.

### 4.4 Widgets (`widgets.py`)

Use `FormattedTextControl` for dynamic text:

**Task list widget**:

```python
from prompt_toolkit.layout.controls import FormattedTextControl
from prompt_toolkit.layout import Window
from prompt_toolkit.formatted_text import to_formatted_text

class TaskListControl(FormattedTextControl):
    def __init__(self, state: UIState):
        self.state = state
        super().__init__(self.get_text)

    def get_text(self):
        lines = []
        for i, row in enumerate(self.state.tasks):
            selected = (i == self.state.selected_index)
            style = f\"reverse {row.status_color}\" if selected else row.status_color
            desc = row.description
            if len(desc) > 50:
                desc = desc[:47] + \"...\"
            created = row.created_at.split(\"T\")[0] if row.created_at else \"\"
            text = f\" {row.status_emoji} {row.task_id} {desc} [{created}]\"
            lines.append((style, text + \"\\n\"))
        if not lines:
            lines = [(\"class:dim\", \"No tasks\\n\")]
        return lines

def TaskListWindow(state):
    return Window(TaskListControl(state), wrap_lines=False)
```

**Detail widget**:

Similar `FormattedTextControl` that inspects `state.detail_tab` and `state.selected_task.details` and builds formatted text.

**Status bar**:

```python
class StatusBarControl(FormattedTextControl):
    def __init__(self, state):
        self.state = state
        super().__init__(self.get_text)

    def get_text(self):
        mode = \"COMMAND\" if self.state.command_active else \"NORMAL\"
        filt = self.state.status_filter or \"all\"
        msg = self.state.busy_label or self.state.message or \"\"
        # limit length
        msg = msg[:80]
        text = f\" {mode} | filter:{filt} | tasks:{len(self.state.tasks)} | {msg}\"
        return [(\"class:status\", text)]
```

Place in a `Window(height=1, ...)`.

**Command line overlay**

- When `state.command_active` true, show a bottom float:

```python
from prompt_toolkit.widgets import TextArea

def CommandLineWidget(buffer):
    return TextArea(
        height=1,
        prompt=':',
        style='class:commandline',
        multiline=False,
        wrap_lines=False,
        buffer=buffer,
    )
```

In `layout`, attach buffer and show/hide Float depending on state (via a dummy `ConditionalContainer` or by having `get_children` consult state).

### 4.5 Layout (`layout.py`)

Sketch:

```python
from prompt_toolkit.layout import Layout, HSplit, VSplit, Window, FloatContainer, Float
from prompt_toolkit.layout.containers import ConditionalContainer
from .widgets import TaskListWindow, DetailWindow, StatusBarControl, CommandLineWidget

def create_root_container(state, cmd_buffer):
    body = VSplit([
        TaskListWindow(state),
        Window(width=1, char='â”‚', style='class:separator'),
        DetailWindow(state),
    ])
    status = Window(StatusBarControl(state), height=1, style='class:statusbar')

    command_line = ConditionalContainer(
        content=CommandLineWidget(cmd_buffer),
        filter=lambda: state.command_active,
    )

    root = FloatContainer(
        content=HSplit([
            body,
            status,
        ]),
        floats=[
            Float(bottom=0, left=0, right=0, content=command_line),
            # other modals as needed
        ],
    )
    return root

def create_layout(state, cmd_buffer):
    root = create_root_container(state, cmd_buffer)
    return Layout(root)
```

### 4.6 Keybindings (`keybindings.py`)

Example:

```python
from prompt_toolkit.key_binding import KeyBindings
from prompt_toolkit.filters import vi_insert_mode, has_focus
from prompt_toolkit.application.current import get_app

def create_keybindings(state, controller, task_list_window, cmd_buffer):
    kb = KeyBindings()

    @kb.add('j', filter=~vi_insert_mode & has_focus(task_list_window))
    def _(event):
        if state.selected_index < len(state.tasks) - 1:
            state.selected_index += 1
            controller._ensure_selected_task_loaded()

    @kb.add('k', filter=~vi_insert_mode & has_focus(task_list_window))
    def _(event):
        if state.selected_index > 0:
            state.selected_index -= 1
            controller._ensure_selected_task_loaded()

    @kb.add('h', filter=~vi_insert_mode)
    def _(event):
        state.focus_panel = 'list'
        get_app().layout.focus(task_list_window)

    @kb.add('l', filter=~vi_insert_mode)
    def _(event):
        # focus detail (some Window instance)
        state.focus_panel = 'detail'
        get_app().layout.focus(/* detail window ref */)

    @kb.add('s', filter=~vi_insert_mode)
    def _(event):
        # open submit modal via controller/show_modal fn
        ...

    @kb.add(':', filter=~vi_insert_mode)
    def _(event):
        state.command_active = True
        state.command_buffer = \"\"
        cmd_buffer.text = \"\"
        get_app().layout.focus(cmd_buffer)

    # Command buffer: Enter / Esc
    @kb.add('enter', filter=has_focus(cmd_buffer))
    def _(event):
        line = cmd_buffer.text
        state.command_active = False
        # dispatch
        controller.execute_command(line)
        cmd_buffer.text = \"\"

    @kb.add('escape', filter=has_focus(cmd_buffer))
    def _(event):
        state.command_active = False
        cmd_buffer.text = \"\"
        # return focus to list
        get_app().layout.focus(task_list_window)
```

`execute_command` is a method on `TUIController` to parse & call appropriate actions (mapping to Slack/CLI equivalents).

### 4.7 Application wiring (`app.py`)

```python
import asyncio
from prompt_toolkit.application import Application
from prompt_toolkit.styles import Style
from prompt_toolkit.buffer import Buffer
from prompt_toolkit.key_binding.bindings.vi import load_vi_bindings
from prompt_toolkit.key_binding import merge_key_bindings
from .models import UIState
from .controllers import TUIController
from .layout import create_layout
from .keybindings import create_keybindings
from nightshift.core.config import Config
from nightshift.core.logger import NightShiftLogger
from nightshift.core.task_queue import TaskQueue
from nightshift.core.task_planner import TaskPlanner
from nightshift.core.agent_manager import AgentManager

def create_app() -> Application:
    cfg = Config()
    logger = NightShiftLogger(log_dir=str(cfg.get_log_dir()))
    queue = TaskQueue(db_path=str(cfg.get_database_path()))
    planner = TaskPlanner(logger, tools_reference_path=str(cfg.get_tools_reference_path()))
    agent = AgentManager(queue, logger, output_dir=str(cfg.get_output_dir()))

    state = UIState()
    controller = TUIController(state, queue, planner, agent, logger, cfg)
    controller.refresh_tasks()

    cmd_buffer = Buffer()

    root_container = create_layout(state, cmd_buffer)
    vi = load_vi_bindings()
    custom = create_keybindings(state, controller, /*task_list window ref*/, cmd_buffer)
    key_bindings = merge_key_bindings([vi, custom])

    style = Style.from_dict({
        \"statusbar\": \"reverse\",
        \"separator\": \"fg:#444444\",
        \"task.id\": \"bold\",
        # add per-status classes if used
    })

    app = Application(
        layout=root_container,
        key_bindings=key_bindings,
        full_screen=True,
        style=style,
        mouse_support=False,
    )

    async def auto_refresh():
        while True:
            await asyncio.sleep(2)
            controller.refresh_tasks()
            app.invalidate()

    app.pre_run_callables.append(lambda: app.create_background_task(auto_refresh()))
    return app
```

`run.py`:

```python
import asyncio
from .app import create_app

def run():
    app = create_app()
    asyncio.run(app.run_async())
```

5. Specific features mapping
----------------------------

Below: Slack feature â†’ TUI behavior â†’ Prompt_toolkit pieces.

### 5.1 `/nightshift submit`

**Slack:**

- Slash command, ephemeral "Planning taskâ€¦".
- After planning, send approval message with buttons.

**TUI:**

- `s` key or `:submit ...`.

Two UX variants:

1. **Interactive dialog (recommended)**:

   - Press `s`:
     - Open modal with:
       - `TextArea` for description.
       - Checkbox `[ ] Auto-approve`.
       - Optional `allow-dir` text field.
     - "Submit" button calls `controller.submit_task(desc, auto_approve, allow_dirs)` via background thread.
     - Status bar shows "Planning taskâ€¦".
     - On completion, left list updated; if not auto-approve, task appears as STAGED, and overview tab shows plan.

   PT components: `widgets.Dialog`, `TextArea`, `Checkbox`, `Button`.

2. **Command-line**:

   - `:submit \"do X\"` â†’ direct call `submit_task(\"do X\", auto_approve=False)`.
   - `:submit! \"do X\"` â†’ `auto_approve=True`.

### 5.2 Approval Interface

**Slack:**

- Buttons: Approve/Reject/Details in message.

**TUI:**

- Task-level keys on selected row:

  - `a` â†’ `controller.approve_selected()`.
  - `r` â†’ `controller.cancel_selected()` (reject).
  - `Enter` or `d` â†’ `controller.show_details_modal(selected_task)`.

The manual operations within controller replicate SlackEventHandler:

- Approve:
  - Update `TaskStatus.COMMITTED`.
  - Call `execute_task` in thread.
  - Update status message.

- Reject:
  - Update `TaskStatus.CANCELLED`.

- Details:
  - Use same info as `SlackEventHandler.handle_details`:
    - Tools list.
    - Allowed directories.
    - System prompt.
  - Render as a scrollable `TextArea` in a `Dialog`.

### 5.3 `/nightshift queue`

**Slack:**

- Returns task list; optional status filter.

**TUI:**

- Left pane always acts as queue view.
- Filter via:
  - `f` or `:queue staged` â†’ set `state.status_filter='staged'` and `controller.refresh_tasks()`.

PT pieces: custom `TaskListControl` + `Window`.

### 5.4 `/nightshift status`

**Slack:**

- Shows status, description, timestamps, output path.

**TUI:**

- `:status task_xxx`:
  - `controller.select_task(task_id)` finds row, sets `selected_index`, refreshes selected task data.
  - `overview` tab shows:

    - Status emoji & text.
    - Description.
    - Created/started/completed.
    - Result path, error message.

Essentially the right panel `overview` tab is a persistent / richer `status` view.

### 5.5 Process control (pause/resume/kill/cancel)

**Slack:**

- `/nightshift pause|resume|kill|cancel task_id`.

**TUI:**

Bindings:

- `p` â†’ `controller.pause_selected()`.
- `P` â†’ `controller.resume_selected()`.
- `X` â†’ confirm then `kill_selected()`.
- `r` â†’ cancel STAGED/COMMITTED tasks.

Commands:

- `:pause task_x`, `:resume task_x`, `:kill task_x`, `:cancel task_x` all call same controller methods, optionally selecting the given task in the list.

Underlying calls same as Slack handler:

- `AgentManager.pause_task`
- `AgentManager.resume_task`
- `AgentManager.kill_task`
- `TaskQueue.update_status(...CANCELLED...)`

### 5.6 Rich notifications

**Slack:**

- SlackFormatter builds blocks showing:
  - What you asked for.
  - What NightShift found/created (extract stream-json text).
  - File changes.
  - Execution metrics.
  - Result path.

**TUI:**

- Summary tab in right panel:

  - Loads `notifications/task_XXX_notification.json`.
  - Optionally re-extracts Claude response from `output/task_XXX_output.json` as SlackFormatter does.
  - Displays sections using headings with color/emojis:
    - e.g., `What you asked for:`, `What NightShift found/created:`, etc.

Implementation: either share logic with `SlackFormatter` (refactor into reusable helper) or replicate text extraction code in TUI.

PT: `FormattedTextControl`/`TextArea` with `style` segments.

### 5.7 Live updates

**Slack:**

- Currently limited; improvement planned in Phase 2.

**TUI:**

- Auto-refresh tasks every 1â€“2 seconds via background asyncio task.
- For selected RUNNING task in `exec` tab:

  - Periodically read its `output.json`:
    - Show:
      - Live execution time.
      - Last ~30 stream-json lines parsed into user-friendly text (reuse subset of `OutputViewer`).
  - If `TaskQueue` status flips to COMPLETED/FAILED, re-load details and mark summary.

PT: `Application.create_background_task(auto_refresh())`.

### 5.8 Details modal

**Slack:**

- "â„¹ï¸ Details" button â†’ ephemeral message with:
  - Description, status, estimates, tools, dirs, system prompt snippet.

**TUI:**

- `Enter`/`d` â†’ modal dialog:

  - Multi-section text using `TextArea`:
    - "Description",
    - "Status / Estimates / Needs Git",
    - "Allowed Tools",
    - "Allowed Directories",
    - "System Prompt (first 500 chars)".

Implementation: copy `SlackEventHandler.handle_details`' content construction, but display as text instead of Slack markdown.

PT: `Dialog` (widgets), containing a `TextArea(read_only=True, scrollbar=True)`.

6. Code organization & gotchas
------------------------------

### 6.1 Suggested organization

```text
nightshift/interfaces/
  cli.py
  tui/
    __init__.py
    app.py           # create_app, auto_refresh
    layout.py        # containers & FloatContainer
    keybindings.py   # create_keybindings(state, controller, ...)
    models.py        # UIState, TaskRow, SelectedTaskState
    controllers.py   # TUIController
    widgets.py       # TaskListWindow, DetailWindow, StatusBar, Modals
    run.py           # run() for entrypoint
```

Class roles:

- `UIState` â€“ purely front-end state, decoupled from DB.
- `TUIController` â€“ orchestrates operations, the analog of `SlackEventHandler` but synchronous and UI-aware.
- `TaskListControl`, `DetailControl`, `StatusBarControl` â€“ renderers.
- `SubmitDialog`, `ConfirmDialog`, `DetailsDialog` â€“ small helper factories in `widgets.py` returning PT containers.

### 6.2 Phased implementation approach

**Phase 0 â€“ Skeleton**

- Add package, `create_app`, `run_tui` + `nightshift tui` command.
- Show "Hello" static layout to confirm prompt_toolkit works.

**Phase 1 â€“ Read-only queue & details**

- Implement `UIState`, `TaskRow`, `TUIController.refresh_tasks`.
- Left panel list with navigation.
- Right panel overview for selected task (no actions yet).
- Status bar with count and filter.
- `q` to exit.

**Phase 2 â€“ Command mode & filters**

- Add `:` command line & `execute_command` for:
  - `queue [status]`,
  - `status [task_id]`,
  - `results [task_id]` (just select and switch to Summary tab).
- Status filter and auto-refresh loop.

**Phase 3 â€“ Submission & approval**

- Submit modal (`s`) and `:submit`.
- Reuse `TaskPlanner` + `TaskQueue.create_task`.
- Overview shows plan details for STAGED tasks.
- `a` / `r` on selected tasks.
- Execution via `AgentManager.execute_task` in background thread.

**Phase 4 â€“ Process control & live exec tab**

- Implement `p/P/X` and `:pause/resume/kill/cancel`.
- Exec tab: show current stdout snippet, refresh via background task.
- Basic "Running X.Xs" indicator.

**Phase 5 â€“ Slack-like summary & files tab**

- Use notifications JSON to render rich summary.
- Implement files tab with `FileTracker` JSON.
- Polish styles (colors, separators, emojis).

### 6.3 Prompt_toolkit gotchas

- **Thread safety**: Only call `Application.invalidate()` and mutate simple state from worker threads. Avoid `layout.focus` from threads; schedule such actions via `app.create_background_task` or keep them in key handlers.
- **Heavy I/O**: Output JSON can be large; limit how much you parse & display each tick (e.g., only last N lines, and parse once until filesize changes).
- **Vi bindings**: `load_vi_bindings()` will already bind `j/k/h/l`; ensure your custom bindings run in correct filters (`has_focus(task_list_window)` etc.) to avoid weird interactions.
- **SQLite concurrency**: Current `TaskQueue` opens/closes connections per call, which is safe for multiple threads under low write volume, but avoid long transactions. You're mainly doing short `SELECT` & `UPDATE`.
- **Small terminals**: Implement graceful truncation and consider hiding some columns when width is small (or letting PT wrap lines).

---

This plan gives you a concrete path from "basic TUI shell" up to "full Slack parity" while leveraging as much existing code as possible (Slack handlers, CLI behavior, SlackFormatter's summary logic). Once you start implementing, it's natural to pull specific pieces (e.g., details text construction, summary parsing) directly from `slack_handler.py` and `slack_formatter.py` into `controllers.py` / `widgets.py` with minimal changes.
